<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Board — {{ user }}</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; font-family:-apple-system,system-ui,sans-serif; }
    #viewport { position:relative; width:100%; height:100%; background:#f6f6f6; touch-action:none; }
    #world { position:absolute; left:0; top:0; transform-origin:0 0; }
    .frame {
      position:absolute; border:2px solid #cfcfcf; border-radius:16px; background:#ffffffcc;
      box-sizing:border-box; padding:10px;
    }
    .frame .title { font-weight:600; margin-bottom:8px; }
    .frame-label {
      position:absolute;
      padding:4px 12px;
      border-radius:12px;
      background:#fff;
      border:1px solid #ddd;
      box-shadow:0 6px 16px rgba(0,0,0,.08);
      font-weight:600;
      pointer-events:none;
      z-index:5;
      white-space:nowrap;
    }
    .note {
      position:absolute; width:260px; min-height:80px; border-radius:14px; padding:24px 10px 10px;
      background:#fff; border:1px solid #ddd; box-shadow:0 6px 18px rgba(0,0,0,.08);
      box-sizing:border-box; cursor:grab; user-select:none; touch-action:none;
    }
    .note.attached { border-color:#94a3b8; box-shadow:0 8px 24px rgba(15,23,42,.18); }
    .note.dragging { cursor:grabbing; z-index:5; }
    .note .actions { position:absolute; top:6px; right:6px; display:flex; gap:6px; pointer-events:auto; }
    .note .action-btn {
      border:1px solid #d4d4d4; background:#fff; border-radius:8px; padding:2px 6px; cursor:pointer; font-size:14px;
    }
    .note .action-btn { touch-action:manipulation; }
    .note .action-btn.delete { color:#b91c1c; border-color:#f0b4b4; }
    .note .body { white-space:pre-wrap; }
    .note[data-sev="high"] { border-color:#d66; }
    .note[data-sev="low"] { opacity:.85; }
    .note .meta { margin-top:8px; font-size:12px; color:#666; display:flex; gap:8px; flex-wrap:wrap; }
    .chip { padding:2px 8px; border:1px solid #ddd; border-radius:999px; }
    #hud {
      position:fixed; left:12px; top:12px; background:#fff; border:1px solid #ddd;
      border-radius:12px; padding:10px; box-shadow:0 8px 22px rgba(0,0,0,.08); z-index:10;
      display:flex; gap:10px; align-items:center;
    }
    button { border:1px solid #ddd; background:#fff; border-radius:10px; padding:8px 10px; }
    #noteForm, #noteEditForm {
      position:fixed; left:0; top:0; width:320px; background:#fff; border:1px solid rgba(0,0,0,.1);
      border-radius:14px; padding:16px; box-shadow:0 20px 40px rgba(0,0,0,.1); display:none; z-index:10;
    }
    #noteForm.visible, #noteEditForm.visible { display:block; }
    #noteForm textarea, #noteEditForm textarea { width:100%; resize:none; border:1px solid #ccc; border-radius:10px; padding:8px; font:16px/1.4 system-ui; }
    #noteForm input, #noteForm select, #noteEditForm select, #noteEditForm input {
      width:100%; border:1px solid #ccc; border-radius:10px; padding:8px; font:16px/1.4 system-ui; margin-top:8px;
    }
    #noteForm .form-actions, #noteEditForm .form-actions { display:flex; justify-content:flex-end; gap:8px; margin-top:12px; }
    #noteForm button, #noteEditForm button { border-radius:10px; border:1px solid #1d4ed8; background:#1d4ed8; color:#fff; padding:8px 12px; cursor:pointer; }
    #noteForm button[type="button"], #noteEditForm button[type="button"] { background:#f3f4f6; color:#111; border-color:#cbd5f5; }
    #noteForm .hint, #noteEditForm .hint { font-size:12px; color:#777; margin-top:6px; }
    #noteForm .form-heading, #noteEditForm .form-heading { font-weight:600; margin-bottom:8px; }
    #noteEditForm .field-label { font-size:12px; color:#444; margin-top:10px; display:block; }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>{{ user }}</b></div>
    <button id="btnZoomIn">Zoom +</button>
    <button id="btnZoomOut">Zoom -</button>
    <button id="btnNewNote">Новая заметка</button>
    <button id="btnProcess">Process by LLM</button>
    <button id="btnReset">Reset view</button>
  </div>
  <div id="noteForm">
    <form id="createNoteForm">
      <div class="form-heading">Новая заметка</div>
      <textarea name="text" rows="3" placeholder="Что произошло?" required maxlength="2000"></textarea>
      <div class="form-actions">
        <button type="button" id="btnCancelNote">Отменить</button>
        <button type="submit">Создать в центре</button>
      </div>
      <div class="hint">После создания заметка появится в центре видимой области.</div>
    </form>
  </div>
  <div id="noteEditForm">
    <form id="editNoteForm">
      <div class="form-heading">Редактировать заметку</div>
      <textarea name="text" rows="3" placeholder="Что произошло?" required maxlength="2000"></textarea>
      <label class="field-label" for="editSeverity">Важность</label>
      <select id="editSeverity" name="severity">
        <option value="normal">normal</option>
        <option value="low">low</option>
        <option value="high">high</option>
      </select>
      <label class="field-label" for="editNotify">Время</label>
      <input id="editNotify" name="notify_time" type="datetime-local">
      <div class="form-actions">
        <button type="button" id="btnCancelEdit">Отменить</button>
        <button type="submit">Сохранить</button>
      </div>
      <div class="hint">Время используется для напоминаний (notify_by=time).</div>
    </form>
  </div>
  <div id="viewport">
    <div id="world"></div>
  </div>

<script>
const user = {{ user | tojson }};
{% raw %}
const viewport = document.getElementById('viewport');
const world = document.getElementById('world');
const btnZoomIn = document.getElementById('btnZoomIn');
const btnZoomOut = document.getElementById('btnZoomOut');
const btnNewNote = document.getElementById('btnNewNote');
const btnProcess = document.getElementById('btnProcess');
const btnReset = document.getElementById('btnReset');
const noteForm = document.getElementById('noteForm');
const createNoteForm = document.getElementById('createNoteForm');
const btnCancelNote = document.getElementById('btnCancelNote');
const noteEditForm = document.getElementById('noteEditForm');
const editNoteForm = document.getElementById('editNoteForm');
const btnCancelEdit = document.getElementById('btnCancelEdit');

let scale = 1;
let panX = 0, panY = 0;
let data = null;
let frames = new Map();
let frameLabels = new Map();
let notes = new Map();
let lastCursor = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
const pointers = new Map();
let isPinching = false;
let pinchStartDist = 1;
let pinchStartScale = 1;
let pinchCenter = { x: 0, y: 0 };
let pinchWorldCenter = { x: 0, y: 0 };
let editingNoteId = null;
let hasAutoFit = false;
const noteVerticalSpacing = 140;
let nextNotePosition = null;
const focusNoteId = (() => {
  const params = new URLSearchParams(window.location.search);
  const raw = params.get('focus_note_id');
  const id = raw ? parseInt(raw, 10) : null;
  return Number.isFinite(id) ? id : null;
})();
const cameraStorageKey = `board_camera_${user}`;
const cameraSaveDebounceMs = 150;
let cameraSaveTimer = null;
const listLayoutPadding = 16;
const listLayoutGap = 12;
let pendingLayoutFrameId = null;
const listRowStartX = 120;
const listRowStartY = 120;
const listRowGap = 40;
const frameLabelOffset = 32;

function applyTransform() {
  world.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  scheduleCameraSave();
}

function worldToScreen(x,y) {
  return { x: x*scale + panX, y: y*scale + panY };
}

function screenToWorld(x,y) {
  return { x: (x - panX)/scale, y: (y - panY)/scale };
}

window.addEventListener('pointermove', (event) => {
  lastCursor = { x: event.clientX, y: event.clientY };
});

async function loadBoard() {
  const res = await fetch(`/api/board/${encodeURIComponent(user)}`);
  data = await res.json();
  await layoutListsHorizontally();
  refreshNextNotePositionFromData();
  render();
  if (!hasAutoFit) {
    const restored = restoreCamera();
    if (restored) {
      hasAutoFit = true;
      return;
    }
    fitViewToLists();
    hasAutoFit = true;
  }
  if (focusNoteId) {
    focusOnNote(focusNoteId);
  }
}

async function layoutListsHorizontally() {
  if (!data?.lists?.length) return;
  const baseY = data.lists[0]?.pos_y ?? listRowStartY;
  for (let i = 0; i < data.lists.length; i += 1) {
    const fr = data.lists[i];
    const desiredX = listRowStartX + i * (fr.width + listRowGap);
    const desiredY = baseY;
    const needsUpdate = Math.abs(fr.pos_x - desiredX) > 1 || Math.abs(fr.pos_y - desiredY) > 1;
    if (!needsUpdate) continue;
    fr.pos_x = desiredX;
    fr.pos_y = desiredY;
    await patchTodoList(fr.id, { pos_x: desiredX, pos_y: desiredY });
  }
}

function getBoardCenterPosition() {
  return screenToWorld(viewport.clientWidth / 2, viewport.clientHeight / 2);
}

function refreshNextNotePositionFromData() {
  if (data?.notes?.length) {
    const latest = data.notes[0];
    const baseX = latest.pos_x ?? 0;
    const baseY = latest.pos_y ?? 0;
    nextNotePosition = { x: baseX, y: baseY + noteVerticalSpacing };
    return;
  }
  nextNotePosition = getBoardCenterPosition();
}

function getNextNotePlacement() {
  if (!nextNotePosition) {
    refreshNextNotePositionFromData();
  }
  return { ...nextNotePosition };
}

function scheduleCameraSave() {
  if (cameraSaveTimer) {
    clearTimeout(cameraSaveTimer);
  }
  cameraSaveTimer = setTimeout(() => {
    try {
      const payload = JSON.stringify({ panX, panY, scale });
      localStorage.setItem(cameraStorageKey, payload);
    } catch (err) {
      // ignore storage failures
    }
  }, cameraSaveDebounceMs);
}

function restoreCamera() {
  try {
    const raw = localStorage.getItem(cameraStorageKey);
    if (!raw) return false;
    const parsed = JSON.parse(raw);
    if (typeof parsed?.panX !== 'number' || typeof parsed?.panY !== 'number' || typeof parsed?.scale !== 'number') {
      return false;
    }
    panX = parsed.panX;
    panY = parsed.panY;
    scale = Math.min(2.5, Math.max(0.35, parsed.scale));
    applyTransform();
    return true;
  } catch (err) {
    return false;
  }
}

function render() {
  world.innerHTML = '';
  frames.clear();
  frameLabels.clear();
  notes.clear();

  for (const fr of data.lists) {
    const el = document.createElement('div');
    el.className = 'frame';
    el.style.left = fr.pos_x + 'px';
    el.style.top = fr.pos_y + 'px';
    el.style.width = fr.width + 'px';
    el.style.height = fr.height + 'px';
    el.dataset.id = fr.id;
    el.innerHTML = '';
    world.appendChild(el);
    frames.set(fr.id, el);

    const label = document.createElement('div');
    label.className = 'frame-label';
    label.style.left = fr.pos_x + 'px';
    label.style.top = (fr.pos_y - frameLabelOffset) + 'px';
    label.textContent = fr.title;
    world.appendChild(label);
    frameLabels.set(fr.id, label);
  }

  for (const n of data.notes) {
    const el = document.createElement('div');
    el.className = 'note';
    el.style.left = n.pos_x + 'px';
    el.style.top = n.pos_y + 'px';
    el.dataset.id = n.id;
    el.dataset.text = n.text;
    el.dataset.severity = n.severity;
    el.dataset.sev = n.severity;
    el.dataset.todoListId = (n.todo_list_id ?? '');
    el.dataset.notifyTime = n.notify_time ?? '';
    el.dataset.device = n.device ?? '';
    if (n.todo_list_id) {
      el.classList.add('attached');
    }
    const chips = [];
    chips.push(`#${n.id}`);
    if (n.severity) chips.push(`важность:${n.severity}`);
    if (n.device) chips.push(`device:${n.device}`);
    if (n.tag) chips.push(`tag:${n.tag}`);
    const notifyLabel = formatNotifyTime(n.notify_time);
    if (notifyLabel) chips.push(`напомню в "${notifyLabel}"`);
    el.innerHTML = `
      <div class="actions">
        <button class="action-btn note-action note-edit" title="Редактировать">✎</button>
        <button class="action-btn note-action note-delete delete" title="Удалить">×</button>
      </div>
      <div class="body">${escapeHtml(n.text)}</div>
      <div class="meta">
        ${chips.map((chip) => `<span class="chip">${escapeHtml(chip)}</span>`).join('')}
      </div>
    `;
    world.appendChild(el);
    notes.set(n.id, el);
    makeDraggable(el);
    const editBtn = el.querySelector('.note-edit');
    const deleteBtn = el.querySelector('.note-delete');
    const handleEdit = (event) => {
      event.stopPropagation();
      openEditForm(el, event);
    };
    const handleDelete = async (event) => {
      event.stopPropagation();
      const id = parseInt(el.dataset.id, 10);
      if (!id) return;
      if (!confirm('Удалить заметку?')) return;
      await fetch(`/api/notes/${id}`, { method:'DELETE' });
      await loadBoard();
    };
    if (editBtn) {
      editBtn.addEventListener('click', handleEdit);
      editBtn.addEventListener('touchend', handleEdit);
    }
    if (deleteBtn) {
      deleteBtn.addEventListener('click', handleDelete);
      deleteBtn.addEventListener('touchend', handleDelete);
    }
  }
  layoutNotesInFrames();
}

function severityRank(value) {
  if (value === 'high') return 0;
  if (value === 'normal') return 1;
  if (value === 'low') return 2;
  return 3;
}

async function layoutNotesInFrames() {
  if (!data?.lists?.length || !data?.notes?.length) return;
  const notesByFrame = new Map();
  for (const n of data.notes) {
    if (!n.todo_list_id) continue;
    if (!notesByFrame.has(n.todo_list_id)) {
      notesByFrame.set(n.todo_list_id, []);
    }
    notesByFrame.get(n.todo_list_id).push(n);
  }
  for (const fr of data.lists) {
    const items = notesByFrame.get(fr.id);
    if (!items || items.length === 0) continue;
    items.sort((a, b) => {
      const bySeverity = severityRank(a.severity) - severityRank(b.severity);
      if (bySeverity !== 0) return bySeverity;
      return a.id - b.id;
    });
    let currentY = fr.pos_y + listLayoutPadding;
    const baseX = fr.pos_x + listLayoutPadding;
    const maxX = fr.pos_x + fr.width - listLayoutPadding - 260;
    const columnWidth = 260 + listLayoutGap;
    let columnIndex = 0;
    let columnY = currentY;
    let maxBottom = fr.pos_y + listLayoutPadding;
    for (const n of items) {
      const noteEl = notes.get(n.id);
      if (!noteEl) continue;
      const desiredX = Math.min(baseX + columnIndex * columnWidth, maxX);
      const desiredY = columnY;
      noteEl.style.left = desiredX + 'px';
      noteEl.style.top = desiredY + 'px';
      const noteHeight = noteEl.offsetHeight || 100;
      columnY += noteHeight + listLayoutGap;
      const columnBottom = fr.pos_y + fr.height - listLayoutPadding;
      maxBottom = Math.max(maxBottom, desiredY + noteHeight);
      if (columnY + noteHeight > columnBottom && baseX + (columnIndex + 1) * columnWidth <= maxX) {
        columnIndex += 1;
        columnY = currentY;
      }
    }
    const requiredHeight = Math.max(fr.height, (maxBottom - fr.pos_y) + listLayoutPadding);
    if (requiredHeight > fr.height + 1) {
      const frameEl = frames.get(fr.id);
      if (frameEl) {
        frameEl.style.height = requiredHeight + 'px';
      }
      await patchTodoList(fr.id, { height: requiredHeight });
      fr.height = requiredHeight;
    }
    if (pendingLayoutFrameId && pendingLayoutFrameId === fr.id) {
      await persistLayoutForFrame(items);
    }
  }
  pendingLayoutFrameId = null;
}

async function persistLayoutForFrame(items) {
  for (const n of items) {
    const noteEl = notes.get(n.id);
    if (!noteEl) continue;
    const pos_x = parseFloat(noteEl.style.left || '0');
    const pos_y = parseFloat(noteEl.style.top || '0');
    await patchNote(n.id, { pos_x, pos_y, todo_list_id: n.todo_list_id });
  }
}

function focusOnNote(noteId) {
  const note = data?.notes?.find((n) => n.id === noteId);
  if (!note) return;
  const noteCenterX = note.pos_x + 130;
  const noteCenterY = note.pos_y + 40;
  panX = viewport.clientWidth / 2 - noteCenterX * scale;
  panY = viewport.clientHeight / 2 - noteCenterY * scale;
  applyTransform();
}

function escapeHtml(s) {
  return (s ?? '').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;');
}

function formatNotifyTime(value) {
  if (!value) return '';
  const date = new Date(value);
  if (Number.isNaN(date.valueOf())) return '';
  return date.toLocaleString();
}

async function patchNote(id, patch) {
  await fetch(`/api/notes/${id}`, {
    method:'PATCH',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(patch)
  });
}

async function patchTodoList(id, patch) {
  await fetch(`/api/todo_lists/${id}`, {
    method:'PATCH',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(patch)
  });
}

function rect(el) {
  return el.getBoundingClientRect();
}

function intersect(a,b) {
  return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
}

function findFrameUnderNote(noteEl) {
  const nr = rect(noteEl);
  for (const [id, frEl] of frames.entries()) {
    const fr = rect(frEl);
    if (intersect(nr, fr)) return id;
  }
  return null;
}

function makeDraggable(el) {
  let dragging = false;
  let start = null;
  let moved = false;
  let startClient = null;
  let activeTouchId = null;

  const stopDragging = () => {
    dragging = false;
    el.classList.remove('dragging');
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', onMouseUp);
    document.removeEventListener('touchmove', onTouchMove);
    document.removeEventListener('touchend', onTouchEnd);
    document.removeEventListener('touchcancel', onTouchEnd);
    activeTouchId = null;
  };

  const startDragAt = (clientX, clientY) => {
    dragging = true;
    el.classList.add('dragging');
    const p = screenToWorld(clientX, clientY);
    start = {
      mouseX: p.x, mouseY: p.y,
      left: parseFloat(el.style.left || '0'),
      top: parseFloat(el.style.top || '0'),
    };
    moved = false;
    startClient = { x: clientX, y: clientY };
  };

  const moveDragAt = (clientX, clientY) => {
    if (!dragging) return;
    const p = screenToWorld(clientX, clientY);
    const dx = p.x - start.mouseX;
    const dy = p.y - start.mouseY;
    el.style.left = (start.left + dx) + 'px';
    el.style.top = (start.top + dy) + 'px';
    if (!moved && startClient) {
      const dist = Math.hypot(clientX - startClient.x, clientY - startClient.y);
      if (dist > 6) moved = true;
    }
  };

  const finalizeDrag = async (eventLike) => {
    if (!dragging) return;
    stopDragging();

    if (!moved) {
      openEditForm(el, eventLike);
      return;
    }

    const id = parseInt(el.dataset.id, 10);
    const pos_x = parseFloat(el.style.left);
    const pos_y = parseFloat(el.style.top);

    const frameId = findFrameUnderNote(el);
    const patch = { pos_x, pos_y, todo_list_id: frameId };
    await patchNote(id, patch);
    pendingLayoutFrameId = frameId;
    await loadBoard();
  };

  const onMouseMove = (e) => moveDragAt(e.clientX, e.clientY);
  const onMouseUp = (e) => finalizeDrag(e);

  const onTouchMove = (e) => {
    if (activeTouchId === null) return;
    const touch = Array.from(e.changedTouches).find((t) => t.identifier === activeTouchId);
    if (!touch) return;
    e.preventDefault();
    moveDragAt(touch.clientX, touch.clientY);
  };
  const onTouchEnd = (e) => {
    if (activeTouchId === null) return;
    const touch = Array.from(e.changedTouches).find((t) => t.identifier === activeTouchId);
    if (!touch) return;
    finalizeDrag({ clientX: touch.clientX, clientY: touch.clientY });
  };

  el.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return;
    if (e.target.closest('.note-action')) return;
    e.preventDefault();
    startDragAt(e.clientX, e.clientY);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  });

  el.addEventListener('touchstart', (e) => {
    if (e.target.closest('.note-action')) return;
    const touch = e.changedTouches[0];
    if (!touch) return;
    activeTouchId = touch.identifier;
    startDragAt(touch.clientX, touch.clientY);
    document.addEventListener('touchmove', onTouchMove, { passive: false });
    document.addEventListener('touchend', onTouchEnd);
    document.addEventListener('touchcancel', onTouchEnd);
  }, { passive: true });
}

function positionFormNearCursor(el) {
  el.style.left = '0px';
  el.style.top = '0px';
  el.classList.add('visible');
  requestAnimationFrame(() => {
    const rect = el.getBoundingClientRect();
    const left = Math.min(window.innerWidth - rect.width - 12, lastCursor.x + 12);
    const top = Math.min(window.innerHeight - rect.height - 12, lastCursor.y + 12);
    el.style.left = `${Math.max(12, left)}px`;
    el.style.top = `${Math.max(12, top)}px`;
    el.querySelector('textarea')?.focus();
  });
}

function openNoteForm(event) {
  if (event) {
    lastCursor = { x: event.clientX, y: event.clientY };
  }
  positionFormNearCursor(noteForm);
}

function closeForm(el) {
  el.classList.remove('visible');
}

btnNewNote.addEventListener('click', openNoteForm);
btnCancelNote.addEventListener('click', () => closeForm(noteForm));

createNoteForm.addEventListener('submit', async (event) => {
  event.preventDefault();
  const formData = new FormData(createNoteForm);
  const text = (formData.get('text') ?? '').toString().trim();
  if (!text) {
    return;
  }
  const placement = screenToWorld(lastCursor.x, lastCursor.y);
  const x = placement.x;
  const y = placement.y;
  await fetch('/new_note', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      user,
      text,
      device: navigator.userAgent,
      pos_x: x,
      pos_y: y,
    }),
  });
  nextNotePosition = { x, y: y + noteVerticalSpacing };
  closeForm(noteForm);
  createNoteForm.reset();
  await loadBoard();
});

function toDatetimeLocal(value) {
  if (!value) return '';
  const date = new Date(value);
  if (Number.isNaN(date.valueOf())) return '';
  const offset = date.getTimezoneOffset() * 60000;
  return new Date(date.getTime() - offset).toISOString().slice(0, 16);
}

function toIsoTimestamp(value) {
  if (!value) return null;
  const date = new Date(value);
  if (Number.isNaN(date.valueOf())) return null;
  return date.toISOString();
}

function openEditForm(noteEl, event) {
  if (event) {
    lastCursor = { x: event.clientX, y: event.clientY };
  }
  const text = noteEl.dataset.text ?? '';
  const severity = noteEl.dataset.severity ?? 'normal';
  const notifyTime = noteEl.dataset.notifyTime ?? '';
  editingNoteId = parseInt(noteEl.dataset.id, 10);
  const textarea = editNoteForm.querySelector('textarea[name="text"]');
  const severitySelect = editNoteForm.querySelector('select[name="severity"]');
  const notifyInput = editNoteForm.querySelector('input[name="notify_time"]');
  if (textarea) textarea.value = text;
  if (severitySelect) severitySelect.value = severity;
  if (notifyInput) notifyInput.value = toDatetimeLocal(notifyTime);
  positionFormNearCursor(noteEditForm);
}

btnCancelEdit.addEventListener('click', () => {
  editingNoteId = null;
  closeForm(noteEditForm);
});

editNoteForm.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!editingNoteId) return;
  const formData = new FormData(editNoteForm);
  const text = (formData.get('text') ?? '').toString().trim();
  const severity = (formData.get('severity') ?? 'normal').toString();
  const notifyValue = toIsoTimestamp((formData.get('notify_time') ?? '').toString());
  const payload = {
    text,
    severity,
    notify_by: notifyValue ? 'time' : null,
    notify_value: notifyValue ? { at: notifyValue } : null,
  };
  await fetch(`/api/notes/${editingNoteId}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  editingNoteId = null;
  closeForm(noteEditForm);
  await loadBoard();
});

function adjustZoom(factor, focusX = viewport.clientWidth / 2, focusY = viewport.clientHeight / 2) {
  const before = screenToWorld(focusX, focusY);
  scale = Math.min(2.5, Math.max(0.35, scale * factor));
  const after = screenToWorld(focusX, focusY);
  panX += (after.x - before.x) * scale;
  panY += (after.y - before.y) * scale;
  applyTransform();
}

btnZoomIn.addEventListener('click', () => adjustZoom(1.1));
btnZoomOut.addEventListener('click', () => adjustZoom(0.9));

function releasePointer(e) {
  pointers.delete(e.pointerId);
  if (viewport.hasPointerCapture && viewport.hasPointerCapture(e.pointerId)) {
    viewport.releasePointerCapture(e.pointerId);
  }
  capturedPointers.delete(e.pointerId);
  if (isPinching && pointers.size < 2) {
    isPinching = false;
  }
  if (!isPinching) {
    panning = false;
  }
}

let panning = false;
let panStart = null;
const capturedPointers = new Set();

viewport.addEventListener('pointerdown', (e) => {
  pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
  if (pointers.size === 2) {
    isPinching = true;
    panning = false;
    for (const pointerId of pointers.keys()) {
      viewport.setPointerCapture(pointerId);
      capturedPointers.add(pointerId);
    }
    const [a, b] = Array.from(pointers.values());
    const dist = Math.hypot(b.x - a.x, b.y - a.y) || 1;
    pinchStartDist = dist;
    pinchStartScale = scale;
    pinchCenter = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    pinchWorldCenter = screenToWorld(pinchCenter.x, pinchCenter.y);
    return;
  }
  const isNoteElement = !!e.target.closest('.note');
  const isOverlayControl = !!e.target.closest('#noteForm, #noteEditForm, #hud');
  if (!isPinching && !isNoteElement && !isOverlayControl) {
    panning = true;
    panStart = { x: e.clientX, y: e.clientY, panX, panY };
    viewport.setPointerCapture(e.pointerId);
    capturedPointers.add(e.pointerId);
  }
});

viewport.addEventListener('pointermove', (e) => {
  if (!pointers.has(e.pointerId)) return;
  pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
  if (isPinching && pointers.size >= 2) {
    const [a, b] = Array.from(pointers.values());
    const dist = Math.hypot(b.x - a.x, b.y - a.y);
    const factor = dist / (pinchStartDist || 1);
    scale = Math.min(2.5, Math.max(0.35, pinchStartScale * factor));
    const after = worldToScreen(pinchWorldCenter.x, pinchWorldCenter.y);
    panX += pinchCenter.x - after.x;
    panY += pinchCenter.y - after.y;
    applyTransform();
    return;
  }
  if (!panning) return;
  panX = panStart.panX + (e.clientX - panStart.x);
  panY = panStart.panY + (e.clientY - panStart.y);
  applyTransform();
});

viewport.addEventListener('pointerup', (e) => releasePointer(e));
viewport.addEventListener('pointercancel', (e) => releasePointer(e));

viewport.addEventListener('wheel', (e) => {
  e.preventDefault();
  const delta = Math.sign(e.deltaY);
  const factor = (delta > 0) ? 0.9 : 1.1;
  const before = screenToWorld(e.clientX, e.clientY);
  scale = Math.min(2.5, Math.max(0.35, scale * factor));
  const after = screenToWorld(e.clientX, e.clientY);
  panX += (after.x - before.x) * scale;
  panY += (after.y - before.y) * scale;
  applyTransform();
}, { passive:false });

document.addEventListener('keydown', (event) => {
  if (event.key.toLowerCase() === 'n' && !event.metaKey && !event.ctrlKey && !event.altKey) {
    event.preventDefault();
    openNoteForm();
  }
});

btnProcess.addEventListener('click', async () => {
  await fetch(`/api/users/${encodeURIComponent(user)}/process_notes_by_llm`, { method:'POST' });
  await loadBoard();
});

btnReset.addEventListener('click', () => {
  fitViewToLists();
});

applyTransform();
loadBoard();

function fitViewToLists() {
  if (!data || !data.lists || data.lists.length === 0) {
    scale = 1;
    panX = 0;
    panY = 0;
    applyTransform();
    return;
  }
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const fr of data.lists) {
    minX = Math.min(minX, fr.pos_x);
    minY = Math.min(minY, fr.pos_y);
    maxX = Math.max(maxX, fr.pos_x + fr.width);
    maxY = Math.max(maxY, fr.pos_y + fr.height);
  }
  const boundsW = Math.max(1, maxX - minX);
  const boundsH = Math.max(1, maxY - minY);
  const padding = 40;
  const scaleX = (viewport.clientWidth - padding * 2) / boundsW;
  const scaleY = (viewport.clientHeight - padding * 2) / boundsH;
  scale = Math.min(2.5, Math.max(0.35, Math.min(scaleX, scaleY)));
  const centerX = minX + boundsW / 2;
  const centerY = minY + boundsH / 2;
  panX = viewport.clientWidth / 2 - centerX * scale;
  panY = viewport.clientHeight / 2 - centerY * scale;
  applyTransform();
}
{% endraw %}
</script>
</body>
</html>
