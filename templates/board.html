<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Board — {{ user }}</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; font-family:-apple-system,system-ui,sans-serif; }
    #viewport { position:relative; width:100%; height:100%; background:#f6f6f6; touch-action:none; }
    #world { position:absolute; left:0; top:0; transform-origin:0 0; }
    .frame {
      position:absolute; border:2px solid #cfcfcf; border-radius:16px; background:#ffffffcc;
      box-sizing:border-box; padding:10px;
    }
    .frame .title { font-weight:600; margin-bottom:8px; }
    .note {
      position:absolute; width:260px; min-height:80px; border-radius:14px; padding:12px 10px 10px;
      background:#fff; border:1px solid #ddd; box-shadow:0 6px 18px rgba(0,0,0,.08);
      box-sizing:border-box; cursor:grab;
    }
    .note[data-sev="high"] { border-color:#d66; }
    .note[data-sev="low"] { opacity:.85; }
    .note .meta { margin-top:8px; font-size:12px; color:#666; display:flex; gap:8px; flex-wrap:wrap; }
    .chip { padding:2px 8px; border:1px solid #ddd; border-radius:999px; }
    #hud {
      position:fixed; left:12px; top:12px; background:#fff; border:1px solid #ddd;
      border-radius:12px; padding:10px; box-shadow:0 8px 22px rgba(0,0,0,.08); z-index:10;
      display:flex; gap:10px; align-items:center;
    }
    button { border:1px solid #ddd; background:#fff; border-radius:10px; padding:8px 10px; }
    #noteForm, #noteEditForm {
      position:fixed; left:0; top:0; width:320px; background:#fff; border:1px solid rgba(0,0,0,.1);
      border-radius:14px; padding:16px; box-shadow:0 20px 40px rgba(0,0,0,.1); display:none; z-index:10;
    }
    #noteForm.visible, #noteEditForm.visible { display:block; }
    #noteForm textarea, #noteEditForm textarea { width:100%; resize:none; border:1px solid #ccc; border-radius:10px; padding:8px; font:16px/1.4 system-ui; }
    #noteForm input, #noteForm select, #noteEditForm select, #noteEditForm input {
      width:100%; border:1px solid #ccc; border-radius:10px; padding:8px; font:16px/1.4 system-ui; margin-top:8px;
    }
    #noteForm .form-actions, #noteEditForm .form-actions { display:flex; justify-content:flex-end; gap:8px; margin-top:12px; }
    #noteForm button, #noteEditForm button { border-radius:10px; border:1px solid #1d4ed8; background:#1d4ed8; color:#fff; padding:8px 12px; cursor:pointer; }
    #noteForm button[type="button"], #noteEditForm button[type="button"] { background:#f3f4f6; color:#111; border-color:#cbd5f5; }
    #noteForm .hint, #noteEditForm .hint { font-size:12px; color:#777; margin-top:6px; }
    #noteForm .form-heading, #noteEditForm .form-heading { font-weight:600; margin-bottom:8px; }
    #noteEditForm .field-label { font-size:12px; color:#444; margin-top:10px; display:block; }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>{{ user }}</b></div>
    <button id="btnZoomIn">Zoom +</button>
    <button id="btnZoomOut">Zoom -</button>
    <button id="btnNewNote">Новая заметка</button>
    <button id="btnProcess">Process by LLM</button>
    <button id="btnReset">Reset view</button>
  </div>
  <div id="noteForm">
    <form id="createNoteForm">
      <div class="form-heading">Новая заметка</div>
      <textarea name="text" rows="3" placeholder="Что произошло?" required maxlength="2000"></textarea>
      <div class="form-actions">
        <button type="button" id="btnCancelNote">Отменить</button>
        <button type="submit">Создать в центре</button>
      </div>
      <div class="hint">После создания заметка появится в центре видимой области.</div>
    </form>
  </div>
  <div id="noteEditForm">
    <form id="editNoteForm">
      <div class="form-heading">Редактировать заметку</div>
      <textarea name="text" rows="3" placeholder="Что произошло?" required maxlength="2000"></textarea>
      <label class="field-label" for="editSeverity">Важность</label>
      <select id="editSeverity" name="severity">
        <option value="normal">normal</option>
        <option value="low">low</option>
        <option value="high">high</option>
      </select>
      <label class="field-label" for="editNotify">Время</label>
      <input id="editNotify" name="notify_time" type="datetime-local">
      <div class="form-actions">
        <button type="button" id="btnCancelEdit">Отменить</button>
        <button type="submit">Сохранить</button>
      </div>
      <div class="hint">Время используется для напоминаний (notify_by=time).</div>
    </form>
  </div>
  <div id="viewport">
    <div id="world"></div>
  </div>

<script>
const user = {{ user | tojson }};
{% raw %}
const viewport = document.getElementById('viewport');
const world = document.getElementById('world');
const btnZoomIn = document.getElementById('btnZoomIn');
const btnZoomOut = document.getElementById('btnZoomOut');
const btnNewNote = document.getElementById('btnNewNote');
const btnProcess = document.getElementById('btnProcess');
const btnReset = document.getElementById('btnReset');
const noteForm = document.getElementById('noteForm');
const createNoteForm = document.getElementById('createNoteForm');
const btnCancelNote = document.getElementById('btnCancelNote');
const noteEditForm = document.getElementById('noteEditForm');
const editNoteForm = document.getElementById('editNoteForm');
const btnCancelEdit = document.getElementById('btnCancelEdit');

let scale = 1;
let panX = 0, panY = 0;
let data = null;
let frames = new Map();
let notes = new Map();
let lastCursor = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
const pointers = new Map();
let isPinching = false;
let pinchStartDist = 1;
let pinchStartScale = 1;
let pinchCenter = { x: 0, y: 0 };
let pinchWorldCenter = { x: 0, y: 0 };
let editingNoteId = null;

function applyTransform() {
  world.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
}

function worldToScreen(x,y) {
  return { x: x*scale + panX, y: y*scale + panY };
}

function screenToWorld(x,y) {
  return { x: (x - panX)/scale, y: (y - panY)/scale };
}

window.addEventListener('pointermove', (event) => {
  lastCursor = { x: event.clientX, y: event.clientY };
});

async function loadBoard() {
  const res = await fetch(`/api/board/${encodeURIComponent(user)}`);
  data = await res.json();
  render();
}

function render() {
  world.innerHTML = '';
  frames.clear();
  notes.clear();

  for (const fr of data.lists) {
    const el = document.createElement('div');
    el.className = 'frame';
    el.style.left = fr.pos_x + 'px';
    el.style.top = fr.pos_y + 'px';
    el.style.width = fr.width + 'px';
    el.style.height = fr.height + 'px';
    el.dataset.id = fr.id;
    el.innerHTML = `<div class="title">${escapeHtml(fr.title)}</div>`;
    world.appendChild(el);
    frames.set(fr.id, el);
  }

  for (const n of data.notes) {
    const el = document.createElement('div');
    el.className = 'note';
    el.style.left = n.pos_x + 'px';
    el.style.top = n.pos_y + 'px';
    el.dataset.id = n.id;
    el.dataset.text = n.text;
    el.dataset.severity = n.severity;
    el.dataset.todoListId = (n.todo_list_id ?? '');
    el.dataset.notifyTime = n.notify_time ?? '';
    el.innerHTML = `
      <div>${escapeHtml(n.text)}</div>
      <div class="meta">
        <span class="chip">#${n.id}</span>
        <span class="chip">${n.severity}</span>
        <span class="chip">${n.tag ?? 'no-tag'}</span>
        <span class="chip">${n.is_processed_by_llm ? 'llm:yes' : 'llm:no'}</span>
      </div>
    `;
    world.appendChild(el);
    notes.set(n.id, el);
    makeDraggable(el);
    el.addEventListener('dblclick', (event) => {
      event.stopPropagation();
      openEditForm(el, event);
    });
  }
}

function escapeHtml(s) {
  return (s ?? '').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;');
}

async function patchNote(id, patch) {
  await fetch(`/api/notes/${id}`, {
    method:'PATCH',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(patch)
  });
}

function rect(el) {
  return el.getBoundingClientRect();
}

function intersect(a,b) {
  return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
}

function findFrameUnderNote(noteEl) {
  const nr = rect(noteEl);
  for (const [id, frEl] of frames.entries()) {
    const fr = rect(frEl);
    if (intersect(nr, fr)) return id;
  }
  return null;
}

function makeDraggable(el) {
  let dragging = false;
  let start = null;

  el.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    dragging = true;
    el.setPointerCapture(e.pointerId);
    el.style.cursor = 'grabbing';
    const p = screenToWorld(e.clientX, e.clientY);
    start = {
      mouseX: p.x, mouseY: p.y,
      left: parseFloat(el.style.left || '0'),
      top: parseFloat(el.style.top || '0'),
    };
  });

  el.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const p = screenToWorld(e.clientX, e.clientY);
    const dx = p.x - start.mouseX;
    const dy = p.y - start.mouseY;
    el.style.left = (start.left + dx) + 'px';
    el.style.top = (start.top + dy) + 'px';
  });

  el.addEventListener('pointerup', async () => {
    if (!dragging) return;
    dragging = false;
    el.style.cursor = 'grab';

    const id = parseInt(el.dataset.id, 10);
    const pos_x = parseFloat(el.style.left);
    const pos_y = parseFloat(el.style.top);

    const frameId = findFrameUnderNote(el);
    const patch = { pos_x, pos_y, todo_list_id: frameId };
    await patchNote(id, patch);
    await loadBoard();
  });
}

function positionFormNearCursor(el) {
  el.style.left = '0px';
  el.style.top = '0px';
  el.classList.add('visible');
  requestAnimationFrame(() => {
    const rect = el.getBoundingClientRect();
    const left = Math.min(window.innerWidth - rect.width - 12, lastCursor.x + 12);
    const top = Math.min(window.innerHeight - rect.height - 12, lastCursor.y + 12);
    el.style.left = `${Math.max(12, left)}px`;
    el.style.top = `${Math.max(12, top)}px`;
    el.querySelector('textarea')?.focus();
  });
}

function openNoteForm(event) {
  if (event) {
    lastCursor = { x: event.clientX, y: event.clientY };
  }
  positionFormNearCursor(noteForm);
}

function closeForm(el) {
  el.classList.remove('visible');
}

btnNewNote.addEventListener('click', openNoteForm);
btnCancelNote.addEventListener('click', () => closeForm(noteForm));

createNoteForm.addEventListener('submit', async (event) => {
  event.preventDefault();
  const formData = new FormData(createNoteForm);
  const text = (formData.get('text') ?? '').toString().trim();
  if (!text) {
    return;
  }
  const { x, y } = screenToWorld(viewport.clientWidth / 2, viewport.clientHeight / 2);
  await fetch('/new_note', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      user,
      text,
      device: navigator.userAgent,
      pos_x: x,
      pos_y: y,
    }),
  });
  closeForm(noteForm);
  createNoteForm.reset();
  await loadBoard();
});

function toDatetimeLocal(value) {
  if (!value) return '';
  const date = new Date(value);
  if (Number.isNaN(date.valueOf())) return '';
  const offset = date.getTimezoneOffset() * 60000;
  return new Date(date.getTime() - offset).toISOString().slice(0, 16);
}

function toIsoTimestamp(value) {
  if (!value) return null;
  const date = new Date(value);
  if (Number.isNaN(date.valueOf())) return null;
  return date.toISOString();
}

function openEditForm(noteEl, event) {
  if (event) {
    lastCursor = { x: event.clientX, y: event.clientY };
  }
  const text = noteEl.dataset.text ?? '';
  const severity = noteEl.dataset.severity ?? 'normal';
  const notifyTime = noteEl.dataset.notifyTime ?? '';
  editingNoteId = parseInt(noteEl.dataset.id, 10);
  const textarea = editNoteForm.querySelector('textarea[name="text"]');
  const severitySelect = editNoteForm.querySelector('select[name="severity"]');
  const notifyInput = editNoteForm.querySelector('input[name="notify_time"]');
  if (textarea) textarea.value = text;
  if (severitySelect) severitySelect.value = severity;
  if (notifyInput) notifyInput.value = toDatetimeLocal(notifyTime);
  positionFormNearCursor(noteEditForm);
}

btnCancelEdit.addEventListener('click', () => {
  editingNoteId = null;
  closeForm(noteEditForm);
});

editNoteForm.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!editingNoteId) return;
  const formData = new FormData(editNoteForm);
  const text = (formData.get('text') ?? '').toString().trim();
  const severity = (formData.get('severity') ?? 'normal').toString();
  const notifyValue = toIsoTimestamp((formData.get('notify_time') ?? '').toString());
  const payload = {
    text,
    severity,
    notify_by: notifyValue ? 'time' : null,
    notify_value: notifyValue ? { at: notifyValue } : null,
  };
  await fetch(`/api/notes/${editingNoteId}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  editingNoteId = null;
  closeForm(noteEditForm);
  await loadBoard();
});

function adjustZoom(factor, focusX = viewport.clientWidth / 2, focusY = viewport.clientHeight / 2) {
  const before = screenToWorld(focusX, focusY);
  scale = Math.min(2.5, Math.max(0.35, scale * factor));
  const after = screenToWorld(focusX, focusY);
  panX += (after.x - before.x) * scale;
  panY += (after.y - before.y) * scale;
  applyTransform();
}

btnZoomIn.addEventListener('click', () => adjustZoom(1.1));
btnZoomOut.addEventListener('click', () => adjustZoom(0.9));

function releasePointer(e) {
  pointers.delete(e.pointerId);
  viewport.releasePointerCapture(e.pointerId);
  if (isPinching && pointers.size < 2) {
    isPinching = false;
  }
  if (!isPinching) {
    panning = false;
  }
}

let panning = false;
let panStart = null;

viewport.addEventListener('pointerdown', (e) => {
  pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
  viewport.setPointerCapture(e.pointerId);
  if (pointers.size === 2) {
    isPinching = true;
    panning = false;
    const [a, b] = Array.from(pointers.values());
    const dist = Math.hypot(b.x - a.x, b.y - a.y) || 1;
    pinchStartDist = dist;
    pinchStartScale = scale;
    pinchCenter = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    pinchWorldCenter = screenToWorld(pinchCenter.x, pinchCenter.y);
    return;
  }
  if (!isPinching && e.target === viewport) {
    panning = true;
    panStart = { x: e.clientX, y: e.clientY, panX, panY };
  }
});

viewport.addEventListener('pointermove', (e) => {
  if (!pointers.has(e.pointerId)) return;
  pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
  if (isPinching && pointers.size >= 2) {
    const [a, b] = Array.from(pointers.values());
    const dist = Math.hypot(b.x - a.x, b.y - a.y);
    const factor = dist / (pinchStartDist || 1);
    scale = Math.min(2.5, Math.max(0.35, pinchStartScale * factor));
    const after = worldToScreen(pinchWorldCenter.x, pinchWorldCenter.y);
    panX += pinchCenter.x - after.x;
    panY += pinchCenter.y - after.y;
    applyTransform();
    return;
  }
  if (!panning) return;
  panX = panStart.panX + (e.clientX - panStart.x);
  panY = panStart.panY + (e.clientY - panStart.y);
  applyTransform();
});

viewport.addEventListener('pointerup', (e) => releasePointer(e));
viewport.addEventListener('pointercancel', (e) => releasePointer(e));

viewport.addEventListener('wheel', (e) => {
  e.preventDefault();
  const delta = Math.sign(e.deltaY);
  const factor = (delta > 0) ? 0.9 : 1.1;
  const before = screenToWorld(e.clientX, e.clientY);
  scale = Math.min(2.5, Math.max(0.35, scale * factor));
  const after = screenToWorld(e.clientX, e.clientY);
  panX += (after.x - before.x) * scale;
  panY += (after.y - before.y) * scale;
  applyTransform();
}, { passive:false });

document.addEventListener('keydown', (event) => {
  if (event.key.toLowerCase() === 'n' && !event.metaKey && !event.ctrlKey && !event.altKey) {
    event.preventDefault();
    openNoteForm();
  }
});

btnProcess.addEventListener('click', async () => {
  await fetch(`/api/users/${encodeURIComponent(user)}/process_notes_by_llm`, { method:'POST' });
  await loadBoard();
});

btnReset.addEventListener('click', () => {
  scale = 1;
  panX = 0;
  panY = 0;
  applyTransform();
});

applyTransform();
loadBoard();
{% endraw %}
</script>
</body>
</html>
